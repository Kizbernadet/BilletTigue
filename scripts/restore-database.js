/**
 * Script de restauration de la base de donn√©es Billettigue
 * =====================================================
 * 
 * Ce script restaure une sauvegarde de la base de donn√©es
 * avec gestion des erreurs et validation de l'int√©grit√©.
 * 
 * Utilisation :
 * node scripts/restore-database.js [fichier_backup]
 */

const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

// Charger les variables d'environnement depuis le fichier .env du backend
const dotenvPath = path.join(__dirname, '..', 'backend', '.env');
try {
    if (fs.existsSync(dotenvPath)) {
        require('dotenv').config({ path: dotenvPath });
        console.log('‚úÖ Variables d\'environnement charg√©es depuis backend/.env');
    } else {
        console.log('‚ö†Ô∏è  Fichier .env non trouv√© dans backend/, utilisation des valeurs par d√©faut');
    }
} catch (error) {
    console.log('‚ö†Ô∏è  Module dotenv non disponible, utilisation des valeurs par d√©faut');
    console.log('üí° Pour utiliser dotenv, installez-le: npm install dotenv');
}

// Configuration de la base de donn√©es
const DB_CONFIG = {
    name: process.env.DB_NAME || 'billettigue',
    user: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || 'postgres',
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432
};

// Configuration de la restauration
const RESTORE_CONFIG = {
    backupDir: path.join(__dirname, '..', 'backups'),
    createBackup: true,  // Cr√©er une sauvegarde avant restauration
    dropDatabase: false, // Ne pas supprimer la base existante
    verbose: true
};

/**
 * Affiche l'aide du script
 */
function showHelp() {
    console.log(`
üîÑ Script de restauration de la base de donn√©es Billettigue

Utilisation:
  node scripts/restore-database.js [fichier_backup]

Options:
  fichier_backup    Nom du fichier de sauvegarde √† restaurer
                    (sans extension .sql ou .sql.gz)

Exemples:
  node scripts/restore-database.js billettigue_backup_2024-01-15T10-30-00-000Z
  node scripts/restore-database.js latest

Fonctionnalit√©s:
  ‚úÖ Cr√©ation automatique d'une sauvegarde avant restauration
  ‚úÖ Validation du fichier de sauvegarde
  ‚úÖ Restauration s√©curis√©e avec rollback possible
  ‚úÖ V√©rification de l'int√©grit√© apr√®s restauration
`);
}

/**
 * Liste les sauvegardes disponibles
 */
function listAvailableBackups() {
    if (!fs.existsSync(RESTORE_CONFIG.backupDir)) {
        console.log('‚ùå Aucun r√©pertoire de sauvegarde trouv√©');
        return [];
    }
    
    const files = fs.readdirSync(RESTORE_CONFIG.backupDir)
        .filter(file => file.endsWith('.sql') || file.endsWith('.sql.gz'))
        .sort()
        .reverse();
    
    console.log('üìÅ Sauvegardes disponibles:');
    files.forEach((file, index) => {
        const filepath = path.join(RESTORE_CONFIG.backupDir, file);
        const stats = fs.statSync(filepath);
        const size = (stats.size / 1024 / 1024).toFixed(2);
        const date = stats.mtime.toLocaleString();
        console.log(`  ${index + 1}. ${file} (${size} MB) - ${date}`);
    });
    
    return files;
}

/**
 * Trouve le fichier de sauvegarde
 */
function findBackupFile(backupName) {
    if (!fs.existsSync(RESTORE_CONFIG.backupDir)) {
        throw new Error('‚ùå R√©pertoire de sauvegarde introuvable');
    }
    
    let backupFile = null;
    
    if (backupName === 'latest') {
        // Trouver la sauvegarde la plus r√©cente
        const files = fs.readdirSync(RESTORE_CONFIG.backupDir)
            .filter(file => file.endsWith('.sql') || file.endsWith('.sql.gz'))
            .sort()
            .reverse();
        
        if (files.length === 0) {
            throw new Error('‚ùå Aucune sauvegarde trouv√©e');
        }
        
        backupFile = files[0];
    } else {
        // Chercher le fichier exact ou avec extensions
        const possibleFiles = [
            backupName,
            `${backupName}.sql`,
            `${backupName}.sql.gz`
        ];
        
        for (const file of possibleFiles) {
            const filepath = path.join(RESTORE_CONFIG.backupDir, file);
            if (fs.existsSync(filepath)) {
                backupFile = file;
                break;
            }
        }
        
        if (!backupFile) {
            throw new Error(`‚ùå Fichier de sauvegarde '${backupName}' introuvable`);
        }
    }
    
    return path.join(RESTORE_CONFIG.backupDir, backupFile);
}

/**
 * V√©rifie la connectivit√© √† la base de donn√©es
 */
function checkDatabaseConnection() {
    return new Promise((resolve, reject) => {
        const testCommand = `psql -h ${DB_CONFIG.host} -p ${DB_CONFIG.port} -U ${DB_CONFIG.user} -d ${DB_CONFIG.name} -c "SELECT 1;"`;
        
        exec(testCommand, { env: { ...process.env, PGPASSWORD: DB_CONFIG.password } }, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`‚ùå Impossible de se connecter √† la base de donn√©es: ${error.message}`));
            } else {
                console.log('‚úÖ Connexion √† la base de donn√©es √©tablie');
                resolve();
            }
        });
    });
}

/**
 * Cr√©e une sauvegarde de s√©curit√© avant restauration
 */
function createSafetyBackup() {
    return new Promise((resolve, reject) => {
        if (!RESTORE_CONFIG.createBackup) {
            console.log('‚ö†Ô∏è Sauvegarde de s√©curit√© d√©sactiv√©e');
            resolve(null);
            return;
        }
        
        console.log('üõ°Ô∏è Cr√©ation d\'une sauvegarde de s√©curit√©...');
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const safetyFile = `safety_backup_${timestamp}.sql`;
        const safetyPath = path.join(RESTORE_CONFIG.backupDir, safetyFile);
        
        let command = `pg_dump`;
        command += ` -h ${DB_CONFIG.host}`;
        command += ` -p ${DB_CONFIG.port}`;
        command += ` -U ${DB_CONFIG.user}`;
        command += ` -d ${DB_CONFIG.name}`;
        command += ` --clean --if-exists --no-owner --no-privileges`;
        command += ` > "${safetyPath}"`;
        
        exec(command, { env: { ...process.env, PGPASSWORD: DB_CONFIG.password } }, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`‚ùå Erreur lors de la sauvegarde de s√©curit√©: ${error.message}`));
            } else {
                console.log('‚úÖ Sauvegarde de s√©curit√© cr√©√©e:', safetyPath);
                resolve(safetyPath);
            }
        });
    });
}

/**
 * Valide le fichier de sauvegarde
 */
function validateBackupFile(backupPath) {
    return new Promise((resolve, reject) => {
        console.log('üîç Validation du fichier de sauvegarde...');
        
        if (!fs.existsSync(backupPath)) {
            reject(new Error('‚ùå Fichier de sauvegarde introuvable'));
            return;
        }
        
        const stats = fs.statSync(backupPath);
        if (stats.size === 0) {
            reject(new Error('‚ùå Fichier de sauvegarde vide'));
            return;
        }
        
        console.log('‚úÖ Fichier de sauvegarde valide');
        console.log('üìè Taille:', (stats.size / 1024 / 1024).toFixed(2), 'MB');
        resolve();
    });
}

/**
 * Effectue la restauration
 */
function performRestore(backupPath) {
    return new Promise((resolve, reject) => {
        console.log('üîÑ D√©but de la restauration...');
        console.log('üìÅ Fichier source:', backupPath);
        
        const startTime = Date.now();
        
        let command = '';
        
        if (backupPath.endsWith('.gz')) {
            // Fichier compress√©
            command = `gunzip -c "${backupPath}" | psql`;
        } else {
            // Fichier non compress√©
            command = `psql -f "${backupPath}"`;
        }
        
        // Ajouter les param√®tres de connexion
        command += ` -h ${DB_CONFIG.host}`;
        command += ` -p ${DB_CONFIG.port}`;
        command += ` -U ${DB_CONFIG.user}`;
        command += ` -d ${DB_CONFIG.name}`;
        
        if (RESTORE_CONFIG.verbose) {
            command += ` --echo-all`;
        }
        
        exec(command, { env: { ...process.env, PGPASSWORD: DB_CONFIG.password } }, (error, stdout, stderr) => {
            const endTime = Date.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            
            if (error) {
                reject(new Error(`‚ùå Erreur lors de la restauration: ${error.message}`));
            } else {
                console.log(`‚úÖ Restauration termin√©e en ${duration} secondes`);
                resolve({ duration, stdout });
            }
        });
    });
}

/**
 * V√©rifie l'int√©grit√© apr√®s restauration
 */
function verifyRestore() {
    return new Promise((resolve, reject) => {
        console.log('üîç V√©rification de l\'int√©grit√©...');
        
        const verifyCommand = `
            psql -h ${DB_CONFIG.host} -p ${DB_CONFIG.port} -U ${DB_CONFIG.user} -d ${DB_CONFIG.name} -c "
                SELECT 
                    schemaname,
                    tablename,
                    n_live_tup as row_count
                FROM pg_stat_user_tables 
                ORDER BY schemaname, tablename;
            "`;
        
        exec(verifyCommand, { env: { ...process.env, PGPASSWORD: DB_CONFIG.password } }, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`‚ùå Erreur lors de la v√©rification: ${error.message}`));
            } else {
                console.log('üìä √âtat de la base apr√®s restauration:');
                console.log(stdout);
                console.log('‚úÖ V√©rification termin√©e');
                resolve();
            }
        });
    });
}

/**
 * Fonction principale
 */
async function main() {
    try {
        const args = process.argv.slice(2);
        
        if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
            showHelp();
            return;
        }
        
        const backupName = args[0];
        
        console.log('üöÄ D√©but du processus de restauration');
        console.log('üìÖ Date:', new Date().toLocaleString());
        console.log('üóÑÔ∏è Base de donn√©es:', DB_CONFIG.name);
        console.log('üè† H√¥te:', DB_CONFIG.host);
        console.log('üîå Port:', DB_CONFIG.port);
        console.log('üë§ Utilisateur:', DB_CONFIG.user);
        console.log('üìÅ Sauvegarde:', backupName);
        console.log('');
        
        // √âtape 1: Lister les sauvegardes disponibles
        listAvailableBackups();
        console.log('');
        
        // √âtape 2: Trouver le fichier de sauvegarde
        const backupPath = findBackupFile(backupName);
        console.log('üìÅ Fichier s√©lectionn√©:', backupPath);
        
        // √âtape 3: V√©rifier la connexion
        await checkDatabaseConnection();
        
        // √âtape 4: Valider le fichier de sauvegarde
        await validateBackupFile(backupPath);
        
        // √âtape 5: Cr√©er une sauvegarde de s√©curit√©
        const safetyBackup = await createSafetyBackup();
        
        // √âtape 6: Effectuer la restauration
        const restoreInfo = await performRestore(backupPath);
        
        // √âtape 7: V√©rifier l'int√©grit√©
        await verifyRestore();
        
        console.log('');
        console.log('üéâ Restauration termin√©e avec succ√®s!');
        console.log('‚è±Ô∏è Dur√©e:', restoreInfo.duration, 'secondes');
        
        if (safetyBackup) {
            console.log('üõ°Ô∏è Sauvegarde de s√©curit√©:', safetyBackup);
        }
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la restauration:', error.message);
        console.log('');
        console.log('üí° Utilisez --help pour voir les options disponibles');
        process.exit(1);
    }
}

// Ex√©cution du script
if (require.main === module) {
    main();
}

module.exports = {
    performRestore,
    checkDatabaseConnection,
    validateBackupFile,
    verifyRestore
}; 