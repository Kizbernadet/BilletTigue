/**
 * Script de sauvegarde de la base de donn√©es Billettigue
 * ===================================================
 * 
 * Ce script cr√©e une sauvegarde compl√®te de la base de donn√©es
 * avec gestion des erreurs et validation de l'int√©grit√©.
 * 
 * Utilisation :
 * cd backend && node ../scripts/backup-database.js
 * 
 * Ou depuis la racine :
 * node -r dotenv/config scripts/backup-database.js dotenv_config_path=backend/.env
 */

const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

// Charger les variables d'environnement depuis le fichier .env du backend
const dotenvPath = path.join(__dirname, '..', 'backend', '.env');
try {
    if (fs.existsSync(dotenvPath)) {
        require('dotenv').config({ path: dotenvPath });
        console.log('‚úÖ Variables d\'environnement charg√©es depuis backend/.env');
    } else {
        console.log('‚ö†Ô∏è  Fichier .env non trouv√© dans backend/, utilisation des valeurs par d√©faut');
    }
} catch (error) {
    console.log('‚ö†Ô∏è  Module dotenv non disponible, utilisation des valeurs par d√©faut');
    console.log('üí° Pour utiliser dotenv, installez-le: npm install dotenv');
}

// Configuration de la base de donn√©es
const DB_CONFIG = {
    name: process.env.DB_NAME || 'billettigue',
    user: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || 'postgres',
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432
};

// Configuration de la sauvegarde
const BACKUP_CONFIG = {
    outputDir: path.join(__dirname, '..', 'backups'),
    filename: `billettigue_backup_${new Date().toISOString().replace(/[:.]/g, '-')}.sql`,
    compress: true
};

/**
 * Cr√©e le r√©pertoire de sauvegarde s'il n'existe pas
 */
function createBackupDirectory() {
    if (!fs.existsSync(BACKUP_CONFIG.outputDir)) {
        fs.mkdirSync(BACKUP_CONFIG.outputDir, { recursive: true });
        console.log('‚úÖ R√©pertoire de sauvegarde cr√©√©:', BACKUP_CONFIG.outputDir);
    }
}

/**
 * G√©n√®re le nom du fichier de sauvegarde
 */
function generateBackupFilename() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const baseFilename = `billettigue_backup_${timestamp}`;
    
    if (BACKUP_CONFIG.compress) {
        return `${baseFilename}.sql.gz`;
    }
    return `${baseFilename}.sql`;
}

/**
 * Construit la commande pg_dump
 */
function buildPgDumpCommand() {
    const filename = generateBackupFilename();
    const filepath = path.join(BACKUP_CONFIG.outputDir, filename);
    
    let command = `pg_dump`;
    
    // Param√®tres de connexion
    command += ` -h ${DB_CONFIG.host}`;
    command += ` -p ${DB_CONFIG.port}`;
    command += ` -U ${DB_CONFIG.user}`;
    command += ` -d ${DB_CONFIG.name}`;
    
    // Options de sauvegarde
    command += ` --verbose`;           // Affichage d√©taill√©
    command += ` --clean`;             // Ajouter DROP/CREATE
    command += ` --if-exists`;         // IF EXISTS pour les DROP
    command += ` --no-owner`;          // Pas de propri√©taire
    command += ` --no-privileges`;     // Pas de privil√®ges
    command += ` --schema=public`;     // Sch√©ma public uniquement
    command += ` --data-only`;         // Donn√©es uniquement (optionnel)
    
    // Compression si activ√©e
    if (BACKUP_CONFIG.compress) {
        command += ` | gzip > "${filepath}"`;
    } else {
        command += ` > "${filepath}"`;
    }
    
    return { command, filepath, filename };
}

/**
 * V√©rifie la connectivit√© √† la base de donn√©es
 */
function checkDatabaseConnection() {
    return new Promise((resolve, reject) => {
        const testCommand = `psql -h ${DB_CONFIG.host} -p ${DB_CONFIG.port} -U ${DB_CONFIG.user} -d ${DB_CONFIG.name} -c "SELECT 1;"`;
        
        exec(testCommand, { env: { ...process.env, PGPASSWORD: DB_CONFIG.password } }, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`‚ùå Impossible de se connecter √† la base de donn√©es: ${error.message}`));
            } else {
                console.log('‚úÖ Connexion √† la base de donn√©es √©tablie');
                resolve();
            }
        });
    });
}

/**
 * R√©cup√®re les informations sur la base de donn√©es
 */
function getDatabaseInfo() {
    return new Promise((resolve, reject) => {
        const infoCommand = `
            psql -h ${DB_CONFIG.host} -p ${DB_CONFIG.port} -U ${DB_CONFIG.user} -d ${DB_CONFIG.name} -c "
                SELECT 
                    schemaname,
                    tablename,
                    n_tup_ins as inserts,
                    n_tup_upd as updates,
                    n_tup_del as deletes,
                    n_live_tup as live_rows
                FROM pg_stat_user_tables 
                ORDER BY schemaname, tablename;
            "`;
        
        exec(infoCommand, { env: { ...process.env, PGPASSWORD: DB_CONFIG.password } }, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`‚ùå Impossible de r√©cup√©rer les informations: ${error.message}`));
            } else {
                console.log('üìä Informations sur la base de donn√©es:');
                console.log(stdout);
                resolve();
            }
        });
    });
}

/**
 * Effectue la sauvegarde
 */
function performBackup() {
    return new Promise((resolve, reject) => {
        const { command, filepath, filename } = buildPgDumpCommand();
        
        console.log('üîÑ D√©but de la sauvegarde...');
        console.log('üìÅ Fichier de sortie:', filepath);
        
        const startTime = Date.now();
        
        exec(command, { env: { ...process.env, PGPASSWORD: DB_CONFIG.password } }, (error, stdout, stderr) => {
            const endTime = Date.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            
            if (error) {
                reject(new Error(`‚ùå Erreur lors de la sauvegarde: ${error.message}`));
            } else {
                console.log(`‚úÖ Sauvegarde termin√©e en ${duration} secondes`);
                console.log('üìÅ Fichier cr√©√©:', filepath);
                
                // V√©rifier la taille du fichier
                const stats = fs.statSync(filepath);
                const fileSize = (stats.size / 1024 / 1024).toFixed(2);
                console.log('üìè Taille du fichier:', fileSize, 'MB');
                
                resolve({ filepath, filename, duration, fileSize });
            }
        });
    });
}

/**
 * Valide la sauvegarde
 */
function validateBackup(filepath) {
    return new Promise((resolve, reject) => {
        console.log('üîç Validation de la sauvegarde...');
        
        // V√©rifier que le fichier existe et n'est pas vide
        if (!fs.existsSync(filepath)) {
            reject(new Error('‚ùå Fichier de sauvegarde introuvable'));
            return;
        }
        
        const stats = fs.statSync(filepath);
        if (stats.size === 0) {
            reject(new Error('‚ùå Fichier de sauvegarde vide'));
            return;
        }
        
        // V√©rifier le contenu du fichier (premi√®res lignes)
        const readStream = fs.createReadStream(filepath, { encoding: 'utf8' });
        let firstLines = '';
        let lineCount = 0;
        
        readStream.on('data', (chunk) => {
            firstLines += chunk;
            lineCount += (chunk.match(/\n/g) || []).length;
            
            if (lineCount >= 10) {
                readStream.destroy();
            }
        });
        
        readStream.on('end', () => {
            if (firstLines.includes('-- PostgreSQL database dump') || 
                firstLines.includes('pg_dump') ||
                firstLines.includes('CREATE TABLE')) {
                console.log('‚úÖ Contenu de la sauvegarde valide');
                resolve();
            } else {
                reject(new Error('‚ùå Contenu de la sauvegarde invalide'));
            }
        });
        
        readStream.on('error', (error) => {
            reject(new Error(`‚ùå Erreur lors de la validation: ${error.message}`));
        });
    });
}

/**
 * Cr√©e un fichier de m√©tadonn√©es
 */
function createMetadataFile(backupInfo) {
    const metadata = {
        timestamp: new Date().toISOString(),
        database: {
            name: DB_CONFIG.name,
            host: DB_CONFIG.host,
            port: DB_CONFIG.port,
            user: DB_CONFIG.user
        },
        backup: {
            filename: backupInfo.filename,
            filepath: backupInfo.filepath,
            duration: backupInfo.duration,
            fileSize: backupInfo.fileSize,
            compressed: BACKUP_CONFIG.compress
        },
        system: {
            nodeVersion: process.version,
            platform: process.platform,
            arch: process.arch
        }
    };
    
    const metadataPath = path.join(BACKUP_CONFIG.outputDir, `${backupInfo.filename}.json`);
    fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
    
    console.log('üìÑ M√©tadonn√©es sauvegard√©es:', metadataPath);
    return metadataPath;
}

/**
 * Fonction principale
 */
async function main() {
    try {
        console.log('üöÄ D√©but du processus de sauvegarde');
        console.log('üìÖ Date:', new Date().toLocaleString());
        console.log('üóÑÔ∏è Base de donn√©es:', DB_CONFIG.name);
        console.log('üè† H√¥te:', DB_CONFIG.host);
        console.log('üîå Port:', DB_CONFIG.port);
        console.log('üë§ Utilisateur:', DB_CONFIG.user);
        console.log('');
        
        // √âtape 1: Cr√©er le r√©pertoire de sauvegarde
        createBackupDirectory();
        
        // √âtape 2: V√©rifier la connexion
        await checkDatabaseConnection();
        
        // √âtape 3: R√©cup√©rer les informations
        await getDatabaseInfo();
        
        // √âtape 4: Effectuer la sauvegarde
        const backupInfo = await performBackup();
        
        // √âtape 5: Valider la sauvegarde
        await validateBackup(backupInfo.filepath);
        
        // √âtape 6: Cr√©er les m√©tadonn√©es
        const metadataPath = createMetadataFile(backupInfo);
        
        console.log('');
        console.log('üéâ Sauvegarde termin√©e avec succ√®s!');
        console.log('üìÅ Fichier principal:', backupInfo.filepath);
        console.log('üìÑ M√©tadonn√©es:', metadataPath);
        console.log('‚è±Ô∏è Dur√©e:', backupInfo.duration, 'secondes');
        console.log('üìè Taille:', backupInfo.fileSize, 'MB');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la sauvegarde:', error.message);
        process.exit(1);
    }
}

// Ex√©cution du script
if (require.main === module) {
    main();
}

module.exports = {
    performBackup,
    checkDatabaseConnection,
    getDatabaseInfo,
    validateBackup
}; 